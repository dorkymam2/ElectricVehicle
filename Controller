#include <DualTB9051FTGMotorShield.h>
#include <util/atomic.h> // For the ATOMIC_BLOCK macro

#define ENCB 3 // WHITE
#define BUTTON_PIN 2 
volatile int posi = 0; // specify posi as volatile

DualTB9051FTGMotorShield motor;

float targetDistance = 9.42; // set point in meters, 
float targetTime = 15; // target time in seconds
float CPR = 211.2 * 0.25; // counts per revolution
float diameter = 0.073025; // diameter of wheel in  meters
float circumference = PI * diameter; // circukjmference of wheel in meters

// P Control Variables
float setPoint = targetDistance * (1/circumference) * CPR; // target distance in ticks
float error;
float Kp = 0.3; 
float PWM;

float maxPWM = 105;

bool started = false;

void setup() {
  Serial.begin(9600);
  pinMode(ENCB,INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(ENCB),readEncoder,RISING);
 
  motor.init();
  motor.enableDrivers();
}

//*************CONTROL LOOP*************//
void loop() {
  // Read the position in an atomic block to avoid a potential
  // misread if the interrupt coincides with this code running
  // see: https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/volatile/
  if (!started) {
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(1000);
      posi = 0;
      started = true;
    }
    return;
  }

  float pos = 0;
  unsigned long now = millis();
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    pos = posi;
  }

  //Velocity Control
  if (pos <= 0.75*setPoint){
    if (pos <= 0.05 * setPoint){
      PWM = 120;
      motor.setM1Speed(PWM);
    }

    else {
      PWM = 105;
      motor.setM1Speed(PWM);
      
    }
  }

  //Position control
  else {
    error = setPoint - pos;
    PWM = Kp * error;
    if (error <= 0){
      PWM = 0;
    }
    if (PWM >= maxPWM){
      PWM = maxPWM;
    }
   
    motor.setM1Speed(PWM);
  }
}
 
void readEncoder(){
  int b = digitalRead(ENCB);
  if(b > 0){
    posi++;
  }
  else{
    posi--;
  }
}
